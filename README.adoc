= README for FTY

== TL;DR summary

This repository allows to quickly checkout, build, test and develop the
ecosystem of http://42ity.org/[42ITy(TM)] project, including components
of the project itself and customized or original dependency projects.

To build the latest HEAD of each component's default branch just run this:
----
$ git clone https://github.com/42ity/FTY && \
  ( cd FTY && make world )
----

It is recommended to have installed `ccache` to speed up subsequent
rebuilds, as well as certain other common dependencies and tools.
For reference, you can find a list of additional packages needed on
Debian and Ubuntu Linux distributions in the `.travis.yml` file.

== About the FTY repository

FTY is a "dispatcher" repository which links (as "git submodules") to the
repositories used to build the 42ITy(TM) project. This includes some third
party projects (git HEADs), forks of third-party projects customized for
42ITy(TM) needs, and of course lots of original development.

For a rebuild from scratch you'd need to compile and install the following
components in order (this is automated by the accompanying `Makefile`):

* `gsl` and `zproject` (optional -- to refresh project definitions)
* `libzmq`
* `libczmq` (one of the supported `czmq` variants as discussed below)
* `malamute`
* `cxxtools`
* `tntdb`
* `fty-proto`
* other `fty-*` components as needed and possibly with dependencies on
  each other as defined in their `profile.xml` manifests for `zproject`
* `fty-core` and `fty-rest` possibly come last

== Making the ecosystem

The included `Makefile` automates building of project components, including
the customized third-party projects, in the order of dependencies. It is
ready for correct parallel compilation with GNU Make 3.81 or newer, and can
take advantage of `ccache` if available on your system. It is up to the
developer to provide an environment with appropriate third-party software
which our project does not modify (such as MySQL/MariaDB libraries to link
against, or lua-5.1/5.2, etc.), as well as internet connection to completely
check out the source code to build. The `Makefile` defines dependencies that
can cause download or update of sources from designated remote repositories
using `git`, so the basic way to build the 42ITy(TM) ecosystem using those
component revisions that the FTY repository points to at any given time is to:

----
$ git clone https://github.com/42ity/FTY && \
  cd FTY && \
  make -j 4
----

To update sources from current state of remote Git branches and rebuild in
proper ordering whatever has changed later on, you can use e.g. `make world`.
You can also do this for initial build command, if you want to build right
away with the current state of default branch in each component repository.

Also you can call a number of actions against specific components using a
metaphor of subdirectory in the recipes, e.g. `make recheck/fty-example`.
See the `Makefile` for different wildcard actions it defines (with percent
character), using this query for the current version: `egrep '/%:$' Makefile`

Note that as part of the project's evolution and legacy, it used to require
the `czmq` version 3.0.2, and since that release was obsoleted by upstream
a while ago, we tracked our own fork with small fixes. Subsequently the code
of 42ITy(TM) components where it mattered was updated to support either the
CZMQ3 or CZMQ4 APIs, and now the `Makefile` in this repository allows to
automate the builds against either our `czmq-v3.0.2` fork or the upstream
`czmq-master` from the GitHub, or using binary packages of zeromq stack
as provided in your OS by other means (beware that these can lag behind
respective upstream/master or upstream/stable branches and so can lack
the features that 42ITy codebase might need). Our current goal is to drop
the requirement of the obsoleted version and use the community-supported
master branch, where we can collaborate on fixes for bugs that bite us all.

To choose the `czmq` version to build your FTY components against, you can
define the `CI_CZMQ_VER=<value>` (as an exported environment variable, or
as a `make` argument); suported values are `3` for our czmq-v3.0.2 fork
(it is also the default choice if no value is set explicitly), `4` for
the upstream/master which is currently under the 4.x umbrella versions,
and `pkg` for OS packages of the whole `libsodium`+`libzmq`+`czmq`+`malamute`
stack.

This `Makefile` has been verified on Debian 8 (devel images for the project
build farm); it also passes on Ubuntu-based systems used in the Travis CI
cloud. Much but not all of this code can also build under OpenIndiana, more
with a purpose to test the approach to portability than to use it there (in
the near term at least). Feel free to update the recipes if needed for other
OSes and distros, and take inspiration from hooks made for and used by the
OpenIndiana/SunOS integration.

== Fetching all current sources and updating the HEADs

Note that when you initially check out a clone of this repository, you only
get meta-data. To instantiate (or subsequently update) the actual source
code for the components, as well as to update the reference to Git HEADs of
the referenced components, run the `./sync.sh` script in this workspace.

NOTE: If you intend not only to build the unmodified 42ITy codebase, but to
also collaborate about changes and improvements, see the chapter below about
setting up your forks on GitHub and how to automate definition of references
to both your "origin" fork and our common "upstream" repository.

NOTE: In order for updates from the common codebase to come without conflicts,
never work in a `master` branch (or other preferred branch in certain repos)!
Use dedicated private branches for development of new features!

TODO: Add a regular job, or one triggered by commits to project repos, to
run such updates and push new references to common FTY dispatcher repo's
`upstream/master`.

== Adding a tracked repository

As new agents and components and perhaps tweaked third-party projects are
added into the mix, either in the common Git organization or in your own
set of FTY repositories forks, you can add and check out new Git submodules
like this:

----
:; git submodule add https://github.com/42ity/fty-new-agent
----

or (to specify a default non-`master` branch right away):

----
:; git submodule add -b 42ity https://github.com/42ity/third-party-fork
----

Note that after adding sources for a submodule, you'd likely want to reference
its place in the dependency chain for the `Makefile` of this FTY workspace
as well (perhaps among `COMPONENTS_FTY_EXPERIMENTAL` first, for skeleton
component directories). Don't forget to `git add` both the updated `Makefile`
and the new component directory, and to set up your own developer fork for it
as detailed below.

== Adding new FTY components

When starting a new component, don't hesitate to start with `fty-example` and
its `project.xml` in particular to seed the generation of your new codebase
in a way similar to our other components.

If your codebase uses features of C++11 or newer standard, see notes in the
`.travis.yml` file (re-)generated for your component about requesting an
appropriate build environment from the Travis CI farm, with a capable compiler.

If the new component delivers `systemd` services that should be manageable
as part of the 42ITy(TM) product, consider updating the list of recognized
services used in `fty-core::tools/systemd` and in `fty-rest::systemctl.ecpp`
(or rather `fty-rest::helpers.cc` at this time).

Finally, although orthogonal to updating this repository, don't forget to
enable Travis CI for the new component and add or update some corresponding
recipes on your build farm, if any.

== Changing tracked repository data

If the submodule configuration needs updates due to evolution over time or
because of initial-setup errors, such as that a different remote repository
or default branch must be tracked, you may want to edit the `.gitmodules`
file directly to set the details you need. It may be required to `git deinit`
an existing working copy of the submodule and check it out again, to use the
new repository tracking metadata - so before such operations do not forget
to commit your changes and push them out into the github fork. Alternately,
local copies of repositories are just directories with special files - so
you can just rename them to sit nearby, and as far as the Git software is
concerned, by this action you've just nuked a checked out submodule and
should simply re-init it again.

== Developer "origin" forks vs. common "upstream" repos

Also note that if you clone `FTY`, the checked-out repositories will likely
initially refer to the component repository URLs as an `origin`, while they
are rather `upstream` for our context (and a real `origin` would be your
development fork of each such component repo you collaborate on). In this
case, change to the subdirectory of the component in question and run the
`git remote` commands to rename references, for example:

----
:; echo 'GITHUB_USER="mygithubname"' > ~/.git-myorigin
:; ./git-myorigin */
----

== More reading

For some more inspiration on workflow with submodules, refer to e.g.:

* https://brooklyn.apache.org/developers/code/git-more.html
* http://stackoverflow.com/a/18799234/4715872
